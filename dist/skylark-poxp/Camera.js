/**
 * skylark-poxp - A version of poxp that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-poxp/
 * @license MIT
 */
define(["./pox","./CanvasMatrix4"],function(a,t){const c=a.RAD,s=t;return a.Camera=class{constructor(a,c){this.poxp=a,this.cam={camCX:0,camCY:0,camCZ:0,camVX:0,camVY:0,camVZ:1,camUPX:0,camUPY:1,camUPZ:0,camRX:30,camRY:-30,camRZ:0,camd:20,camAngle:90,camWidth:1,camNear:.01,camFar:1e3,camGyro:!0,gPad:!0,sbase:.06,moveSpeed:1.3,rotAngle:30,moveY:!1,padMoveUD:!0,padRot:!0,headVec:[0,0,0]};for(let a in c)this.cam[a]=c[a];this.cama=!1,this.rotX=0,this.rotY=0,this.gev=null,this.gx=0,this.gy=0,this.gz=0,this.vcx=0,this.vcy=0,this.vcz=0,this.vrx=0,this.vry=0,this.vrz=0,this.keydown=!1,this.vr=!1,this.camVP=[new t,new t],this.camP=[new t,new t],this.camV=[new t,new t],this.vrv=[new t,new t],this.vrp=[new t,new t],this.tempM=new t,this.pvy=!1,this.pvx=!1}setCam(a){for(let t in a)this.cam[t]=a[t];this.cama=!1}getCam(){const a={basePos:[this.cam.camCX,this.cam.camCY,this.cam.camCZ],baseRot:[this.cam.camRX,this.cam.camRY,this.cam.camRZ],position:Array.from(this.cam.campos),headVec:Array.from(this.cam.headVec)};return this.cam.orientation?a.headOri=Array.from(this.cam.orientation):a.headOri=[0,0,0,1],this.cam.position?a.headPos=Array.from(this.cam.position):a.headPos=[0,0,0],a}vrchange(a){a&&(this.cam.camRX=0,this.cam.camRZ=0)}event(a,t){const s=300*this.poxp.pixRatio/this.poxp.can.width,i=this.poxp.pox.setting&&this.poxp.pox.setting.scale?this.poxp.pox.setting.scale:1;switch(a){case"down":this.rotX=this.cam.camRX,this.rotY=this.cam.camRY;break;case"move":this.cam.camRX=this.rotX+t.dy*s,this.cam.camRY=this.rotY+t.dx*s,this.cam.camRX>89&&(this.cam.camRX=89),this.cam.camRX<-89&&(this.cam.camRX=-89);break;case"up":this.rotX+=t.dy*s,this.rotY+=t.dx*s,null!==this.gev&&(this.gx=this.gev.rx-this.rotX,this.gy=this.gev.ry-this.rotY);break;case"out":this.rotX+=t.dy*s,this.rotY+=t.dx*s;break;case"wheel":this.cam.camd+=t/100*i;break;case"gesture":if(0==t.z)return this.gz=this.cam.camd,!1;this.cam.camd=this.gz/t.z;break;case"gyro":if(this.keydown||!this.cam.camGyro)return!0;if(null===t.rx)return!0;this.gev=t,this.cam.camRX=t.rx-this.gx,this.cam.camRY=t.ry-this.gy,this.cam.camRX>89&&(this.cam.camRX=89),this.cam.camRX<-89&&(this.cam.camRX=-89);break;case"keydown":this.cam.camd;const m=this.cam.moveSpeed;let h="";if(this.keydown=!0,t.altKey)switch(t.key){case"ArrowUp":this.cam.camd=this.cam.camd-m,this.cam.camd<0&&(cthis.am.camd=0);break;case"ArrowDown":this.cam.camd=this.cam.camd+m}else switch(t.key){case"ArrowLeft":case"Left":case"h":this.vry=-m;break;case"ArrowUp":case"Up":case"k":this.vrx=-m;break;case"ArrowRight":case"Right":case"l":this.vry=m;break;case"ArrowDown":case"Down":case"j":this.vrx=m;break;case"w":h="f";break;case"s":h="b";break;case"a":h="l";break;case"d":h="r";break;case"q":h="u";break;case"e":h="d"}if(""!=h){const a=("b"==h||"d"==h?-1:1)*m*i,t=this.cam;if("u"==h||"d"==h)this.vcy=a;else{let s=t.camRY;"l"==h&&(s-=90),"r"==h&&(s+=90),this.vcx=Math.sin(s*c)*a,this.vcz=-Math.cos(s*c)*a}}break;case"keyup":switch(this.keydown=!1,null!==this.gev&&(this.gx=this.gev.rx-this.cam.camRX,this.gy=this.gev.ry-this.cam.camRY),t.key){case"ArrowLeft":case"Left":case"h":case"ArrowRight":case"Right":case"l":this.vry=0;break;case"ArrowUp":case"Up":case"k":case"ArrowDown":case"Down":case"j":this.vrx=0;break;case"w":case"d":case"a":case"s":case" ":this.vcx=0,this.vcz=0;break;case"q":case"e":this.vcy=0;break;case"Dead":this.vrx=0,this.vry=0,this.vcx=0,this.vcz=0}}}update(a){const t=(this.poxp.ctime-this.poxp.ltime)/1e3;"fix"!=this.cam.camMode&&(this.cam.camRX+=this.vrx,this.cam.camRX<-89&&(this.cam.camRX=-89),this.cam.camRX>89&&(this.cam.camRX=89),this.cam.camRY+=this.vry),"walk"==this.cam.camMode&&(this.cama||(this.cam.camCX+=this.vcx*t,this.cam.camCY+=this.vcy*t,this.cam.camCZ+=this.vcz*t),this.cam.camRY+=this.vry*t),this.cama&&(this.cam.camCX+=this.acx*t,this.cam.camCY+=this.acy*t,this.cam.camCZ+=this.acz*t,this.ad+=this.av*t,this.ad>this.al&&(this.cam.camCX=this.aex,this.cam.camCY=this.aey,this.cam.camCZ=this.aez,this.cama=!1))}setPad(a,t){let c=a||t;if(c&&"walk"==this.cam.camMode){let a=[c.axes[0],c.axes[1]];if(void 0!=c.axes[2]&&0!=c.axes[2]&&(a[0]=c.axes[2]),void 0!=c.axes[3]&&0!=c.axes[3]&&(a[1]=c.axes[3]),this.cam.padMoveUD&&c.buttons[1]&&c.buttons[1].pressed)return this.vcy=-a[1]*this.cam.moveSpeed,void(this.pvy=!0);this.pvy&&(this.vcy=0,this.pvy=!1);let t=c.buttons[2]&&c.buttons[2].pressed?5*this.cam.moveSpeed:this.cam.moveSpeed;if(Math.abs(a[0])<Math.abs(a[1])&&Math.abs(a[1])>0)return this.vcx=-this.cam.headVec[0]*a[1]*t,this.cam.moveY&&(this.vcy=-this.cam.headVec[1]*a[1]*t),this.vcz=-this.cam.headVec[2]*a[1]*t,void(this.pvx=!0);if(this.pvx&&(this.vcx=0,this.vcy=0,this.vcz=0,this.pvx=!1),this.cam.padRot&&c.dpad[0]>0){let t=(a[0]>0?1:-1)*this.cam.rotAngle;this.cam.camRY+=t}}}moveTo(a,t,c,s){if(this.cama)return;let i=null!==a?a:this.cam.camCX,m=null!==t?t:this.cam.camCY,h=null!==c?c:this.cam.camCZ;if(s&&s.velocity){let a=i-this.cam.camCX,t=m-this.cam.camCY,c=h-this.cam.camCZ,e=s.velocity/Math.hypot(a,t,c);a*=e,t*=e,c*=e,this.acx=a,this.acy=t,this.acz=c,this.aex=i,this.aey=m,this.aez=h,this.al=s.velocity/e,this.ad=0,this.av=s.velocity,this.cama=!0}else this.cam.camCX=i,this.cam.camCY=m,this.cam.camCZ=h,this.cama=!1}moveCancel(){this.cama=!1}getMtx(a,t){const i=this.cam,m=this.poxp.render.wwg.can,h=m.width/(m.height*(t?2:1));let e,r,o,n,l,v,d,p,C,R,x=null;if(d=i.camUPX,p=i.camUPY,C=i.camUPZ,n=[0,0],l=[0,0],v=[0,0],!this.poxp.isVR){if("fix"==i.camMode)e=i.camVX,r=i.camVY,o=i.camVZ,this.cam.headVec=[e,r,o,0];else if("vr"==i.camMode||"walk"==i.camMode){e=i.camCX+1*Math.sin(i.camRY*c)*Math.cos(i.camRX*c),r=i.camCY+1*-Math.sin(i.camRX*c),o=i.camCZ+1*-Math.cos(i.camRY*c)*Math.cos(i.camRX*c);let a=(new s).rotate(-this.cam.camRX,1,0,0).rotate(-this.cam.camRY,0,1,0).rotate(-this.cam.camRZ,0,0,1);d=-Math.sin(i.camRZ*c),p=Math.cos(i.camRZ*c),this.cam.headVec=a.multVec4(0,0,-1,0)}else{R=i.camd*a,i.camCX=-Math.sin(i.camRY*c)*R*Math.cos(i.camRX*c),i.camCY=Math.sin(i.camRX*c)*R,i.camCZ=Math.cos(i.camRY*c)*R*Math.cos(i.camRX*c),e=0,r=0,o=0,R<0&&(e=2*i.camCX,r=2*i.camCY,o=2*i.camCZ);let t=Math.hypot(i.camCX,i.camCY,i.camCZ);this.cam.headVec=[-i.camCX/t,-i.camCY/t,-i.camCZ/t,0]}if(this.cam.campos=[i.camCX,i.camCY,i.camCZ],this.camVP[0].makeIdentity(),this.camVP[1].makeIdentity(),this.camP[0].makeIdentity(),this.camP[1].makeIdentity(),this.camV[0].makeIdentity(),this.camV[1].makeIdentity(),t){const t=-i.sbase*a;n[0]=p*(i.camCZ-o)-C*(i.camCY-r),l[0]=-d*(i.camCZ-o)+C*(i.camCX-e),v[0]=d*(i.camCY-r)-p*(i.camCX-e);const c=Math.hypot(n[0],l[0],v[0]);n[0]*=t/c,l[0]*=t/c,v[0]*=t/c,n[1]=-n[0],l[1]=-l[0],v[1]=-v[0],this.camV[0].lookat(n[0]+i.camCX,l[0]+i.camCY,v[0]+i.camCZ,e+n[0],r+l[0],o+v[0],d,p,C),this.camV[1].lookat(n[1]+i.camCX,l[1]+i.camCY,v[1]+i.camCZ,e+n[1],r+l[1],o+v[1],d,p,C),0!=i.camAngle?this.camP[0].perspective(i.camAngle,h,i.camNear,i.camFar):this.camP[0].pallarel(i.camd,h,i.camNear,i.camFar),this.camP[1]=this.camP[0],this.camVP[0].load(this.camV[0]).multRight(this.camP[0]),this.camVP[1].load(this.camV[1]).multRight(this.camP[1])}else this.camV[0].lookat(i.camCX,i.camCY,i.camCZ,e,r,o,d,p,C),0!=i.camAngle?this.camP[0].perspective(i.camAngle,h,i.camNear,i.camFar):this.camP[0].pallarel(i.camd,h,i.camNear,i.camFar),this.camVP[0].load(this.camV[0]).multRight(this.camP[0])}if(this.poxp.isVR){if(POXPDevice.setDepth({camNear:i.camNear,camFar:i.camFar}),!(x=POXPDevice.getFrameData()))return;this.cam.orientation=x.pose.orientation,this.cam.position=x.pose.position,this.cam.position||(this.cam.position=[0,0,0]),this.vrv[1].load(x.rightViewMatrix),this.vrv[0].load(x.leftViewMatrix),this.vrp[1].load(x.rightProjectionMatrix),this.vrp[0].load(x.leftProjectionMatrix),this.tempM.makeIdentity().translate(-i.camCX,-i.camCY,-i.camCZ).rotate(i.camRX,1,0,0).rotate(i.camRY,0,1,0).rotate(i.camRZ,0,0,1),this.camV[0].load(this.vrv[0]),this.leftCorrMtx&&this.camV[0].multRight(this.leftCorrMtx),this.camV[0].multLeft(this.tempM),this.camVP[0].load(this.camV[0]).multRight(this.vrp[0]),this.camP[0].load(this.vrp[0]),this.camV[1].load(this.vrv[1]),this.rightCorrMtx&&this.camV[1].multRight(this.rightCorrMtx),this.camV[1].multLeft(this.tempM),this.camVP[1].load(this.camV[1]).multRight(this.vrp[1]),this.camP[1].load(this.vrp[1]);let a=0,t=0,c=1;if(this.cam.orientation){let s=this.cam.orientation[0],i=this.cam.orientation[1],m=this.cam.orientation[2],h=this.cam.orientation[3];a=2*(-s*m-i*h),t=2*(-i*m+s*h),c=s*s+i*i-m*m-h*h;let e=Math.hypot(a,t,c);a/=e,t/=e,c/=e}this.tempM.invert();let m=this.tempM;this.cam.headVec=m.multVec4(a,t,c,0),this.cam.campos=m.multVec4(this.cam.position[0],this.cam.position[1],this.cam.position[2],1).slice(0,3);let h=(new s).load(this.camV[1]).invert(),e=(new s).load(this.camV[0]).invert();n[0]=e.buf[12]-i.camCX,l[0]=e.buf[13]-i.camCY,v[0]=e.buf[14]-i.camCZ,n[1]=h.buf[12]-i.camCX,l[1]=h.buf[13]-i.camCY,v[1]=h.buf[14]-i.camCZ}return[{camX:i.camCX+n[0],camY:i.camCY+l[0],camZ:i.camCZ+v[0],camV:this.camV[0],camVP:this.camVP[0],camP:this.camP[0],vrFrame:x},{camX:i.camCX+n[1],camY:i.camCY+l[1],camZ:i.camCZ+v[1],camV:this.camV[1],camVP:this.camVP[1],camP:this.camP[1],vrFrame:x}]}}});
//# sourceMappingURL=sourcemaps/Camera.js.map
